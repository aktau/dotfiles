#!/bin/bash
#
# memo(1), memoizes the output of your command-line, so you can do:
#
#   $ memo <some long running command> | ...
#
# Instead of
#
#  $ <some long running command> > tmpfile
#  $ cat tmpfile | ...
#  $ rm tmpfile
#
# Provides some nice to haves, like transparant (de)compressing of the output so
# you're less likely to be disk I/O bound and save some space. The order of
# preferred compression algorithms is: lz4, xz, gzip. If none of these programs
# are present on the system, the output is stored uncompressed.
#
# If you think this is handy, you're right. Yet, there are good reasons why this
# sort of tool isn't distributed by default on distributions: it can give
# surprising effects. Suppose the <command> you're trying to memoize depends on
# the current working directory. Changing the directory and running the same
# memo invocation will now paste the wrong data to stdout. Use this only if you
# know what it's doing.
#
# That said, I myself use it a lot, I really can't be bothered to create
# arbitrarily named temporary files all the time when I'm grabbing output from
# some slow networked program.
#
# If you want to memo'ize shell aliases and functions, then you can source this
# script instead of executing it. This will define a function called memo() that
# you can use in exactly the same way. It made the implementation much uglier,
# but at least I can use aliases now.
#
# Don't let the /bin/bash shebang at the top fool you, it runs just fine in zsh.

# Detect being sourced from zsh and bash.
sourced=0
([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
 [[ -n $KSH_VERSION && $(cd "$(dirname -- "$0")" &&
    printf '%s' "${PWD%/}/")$(basename -- "$0") != "${.sh.file}" ]] ||
 [[ -n $BASH_VERSION && $0 != "$BASH_SOURCE" ]]) && sourced=1

memo() {
  __memo_usage() {
      echo "memo [-c] <command>"
      echo ""
      echo "Memoizes the output of <command> and pastes if back to you if run "
      echo "multiple times, without re-running commands. Use memo -c to clear "
      echo "all saved invocation, use memo -c <command> to clear only one "
      echo "invocation."
  }

  # Process options.
  local opt_clear=0
  while getopts :ch opt ; do
    case $opt in
      c) opt_clear=1 ;;
      h) __memo_usage ; return 1 ;;
      ?) (( --OPTIND )) ; break ;;
    esac
  done
  shift $(( OPTIND - 1 ))

  # Ensures that the memodir for $USER exists. If it doesn't exist, tries to
  # create it with the right permissions.
  __memo_ensuredir() {
      local dir="${TMPDIR:-/tmp}/memo"
      [ -d "$dir" ] || mkdir -p "$dir" -m 0777
      dir="$dir/$USER"
      [ -d "$dir" ] || mkdir "$dir" -m 0700
      echo -n "$dir"
  }

  # Generates a hashed __memo_path inside of the memodir. The hash is based on the
  # arguments of this script.
  __memo_path() {
      # Output the first part
      __memo_ensuredir
      # Output a separator
      echo -n "/"
      # Output the hashed arguments and use it as the filename The shasum family
      # of utilities tend to output the hashes in hex format, so no need to fear
      # strange characters being output.
      echo -n "$@" | sha512sum | cut -d' ' -f1
  }

  # Cats a file, decompressing if necessary.
  __memo_catfile() {
    if [ -f "$1.lz4" ] && hash lz4 2>/dev/null ; then
      lz4 -dc < "$1.lz4" || true
    elif [ -f "$1.xz" ] && hash xz 2>/dev/null ; then
      xz -dc < "$1.xz" || true
    elif [ -f "$1.gz" ] && hash gzip 2>/dev/null ; then
      gzip -dc < "$1.gz" || true
    elif [ -f "$1" ] ; then
      cat "$1" || true
    else
      # Cache not found, sad face.
      return 1
    fi
  }
  # Compress standard input to $1.<ext> (.ext is based on the best compression
  # program found).
  __memo_compressfile() {
    if hash lz4 2>/dev/null ; then
      lz4 -9 > "$1.lz4"
    elif hash xz 2>/dev/null ; then
      xz > "$1.xz"
    elif hash gzip 2>/dev/null ; then
      gzip > "$1.gz"
    else
      cat - > "$1"
    fi
  }

  # Blast the entire folder if -c was passed and nothing more.
  if (( opt_clear )) && (( $# == 0 )) ; then
    rm -rf "$(__memo_ensuredir)"
  else
    local file=$(__memo_path "$@")

    # Remove all versions of this hash if -c was passed.
    (( opt_clear )) &&
      find "$(dirname "$file")" -type f -name "$(basename "$file")*" -delete

    # Output the cached file or generate a new one.
    __memo_catfile "$file" || {
      "$@" | tee >(__memo_compressfile "$file")
    }
  fi

  # Clean up
  unset -f __memo_usage
  unset -f __memo_ensuredir
  unset -f __memo_path
  unset -f __memo_catfile
  unset -f __memo_compressfile
}

(( sourced )) && {
  unset sourced
  return 0
}

# If we reach here, we're not being sourced.
set -euo pipefail
memo "$@"
