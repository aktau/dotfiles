export EDITOR=vim

# disable the extremely annoying auto-correct
unsetopt correct_all

# command with a space (' ') before them will not be remembered in
# $HISTFILE, handy for secret commands
setopt HIST_IGNORE_SPACE

# seems to be necessary to make vim mode work right
# bindkey '^[[A' history-substring-search-up
# bindkey '^[[B' history-substring-search-down

# fzf

# use ag to supply fzf with filenames instead of find, it's faster
export FZF_DEFAULT_COMMAND="ag -i --nocolor --nogroup --hidden \
  --ignore .git \
  --ignore .svn \
  --ignore .hg \
  --ignore .DS_Store \
  -g ''"

# Fuzzy cd, powered by fzf. The first argument determines the depth of the
# fuzzy search. 0 is the default and search the current directory only, 1 is
# one level deeper, et cetera.
cdf () {
  local depth=${1:-1}
  cd "$(find . -mindepth 0 -maxdepth "$depth" -type d -printf '%P\n' 2>/dev/null | fzf --select-1 --exit-0)"
}

# Recursive fuzzy cd without limit, uses a depth-first search algorithm so
# that even on very slow filesystems you can navigate piecemeal. You will
# need to acquire this mythical bfsfind monster somewhere though ;).
fd () {
  local dir
  dir="$(bfsfind -type=d . 2>/dev/null | fzf --select-1 --exit-0 )" || {
    return 1
  }
  if [ -z "$dir" ] ; then
    echo "no more directories to enter" >&2
    return 1
  fi
  cd "$dir"
}

# A souped up version of fd that keeps going until you actually quit. Good
# for drilling down into deep hierarchies where even bfsfind has a problem.
#
# Suppose you need to go 6 folders deep, but after 3 the hierarchy because
# too unwieldy and it gets progressively slower: then just select the
# correct folder in the 3rd level and fdr will cd into that and rerun fd.
fdr () {
    while fd ; do : ; done
}

# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe () {
  local file
  file=$(fzf --query="$1" --select-1 --exit-0)
  [ -n "$file" ] && ${EDITOR:-vim} "$file"
}

# fkill - kill process
fkill () {
  pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')

  if [ "x$pid" != "x" ] ; then
    kill -${1:-9} "$pid"
  fi
}

# use trusty OSX names for clipboard interaction
if [[ "$OSTYPE" == 'linux-gnu' ]] ; then
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi

# make LuaJIT nicer to use from the CLI
alias luajit="rlwrap luajit"

# Searches text for a string but highlights instead of filtering. If you
# want to combine this with a pager, it can be piped to less because it has
# --color=always. Alternatively, one can use less -p PATTERN.
greph () {
  local pat="$1"
  shift
  grep --color=always -E "$pat|$" $@
}

# quickly find folders or files in a subdirectory
fname () {
  find . -iname "*$@*"
}

# quickly find folders or files in a subdirectory
fname0 () {
  find . -iname "*$@*" -print0
}

# execute this to try to import any running ssh-agent sessions
ssh-reagent () {
    for agent in /tmp/ssh-*/agent.*; do
       export SSH_AUTH_SOCK=$agent
       if ssh-add -l 2>&1 > /dev/null; then
           echo "Found working SSH Agent:"
           ssh-add -l
           return
       fi
   done

   echo "Cannot find ssh agent - maybe you should reconnect and forward it?"
}

# evaluate something in lua
luae () {
  # dirty hack to force printing of the passed in expression
  local expr="$*"
  case "$expr" in
    *print*|*write*) ;;
    *) expr="printf($expr)" ;;
  esac

  eval "$(luarocks path)" &&
    luajit -e "ml = require('ml'); fun = require('fun'); printf = ml.compose(io.write, string.format); $expr"
}

# start a luajit interpreter with some libraries preloaded
luaj () {
  echo "Loading Microlight"
  echo "  Usage: ml.tstring(val), ml.split('hello dolly'), ml.readfile(fname), ..."
  echo "Loading Luafun"
  echo "  Usage: print(fun.range(100):map(function(x) return x^2 end):reduce(operator.add, 0))"
  eval "$(luarocks path)" &&
    rlwrap luajit -e"ml = require('ml'); fun = require('fun'); printf = ml.compose(io.write, string.format)" -i
}

domain-from-url () {
    local url="$1"
    python -c "from urlparse import urlparse
if '$url'.find('://') == -1:
  url = urlparse('//$url','http')
else:
  url = urlparse('$url')
print url.netloc"
}

fetch-website () {
    local dom
    local url

    if [[ "$#" -eq 2 ]]; then
        url="$2"
        dom="$1"
    else
        url="$1"
        dom=$(domain-from-url $url)
    fi

    wget \
         --recursive \
         --no-clobber \
         --page-requisites \
         --html-extension \
         --convert-links \
         --restrict-file-names=windows \
         --domains "$dom" \
         --no-parent \
         "$url"
}

# Run git-diff on files outside of a repository, to be able to make use of
# its superior diffing ability. Takes care of replacing pipe arguments with
# temporary files, because git diff chokes on those. Includes some handy git
# diff options (that I like) by default.
gdiff() {
    (
    # git diff doesn't accept pipes, so do a temporary copy of any pipes
    # passed as input.
    #
    # Iterating over the positional arguments actually iterates over a copy
    # of the positional arguments in ksh, bash and zsh.
    export TMPDIR=$(mktemp -d)
    trap "rm -rf $TMPDIR" EXIT
    for arg; do
      case "$arg" in
        -*) ;;
        *)
          # Copy the positional argument to a temporary file if it's a pipe.
          if [ -p "${arg}" ] ; then
            f="$(mktemp)" || exit
            cp "${arg}" "$f"
            arg="$f"
          fi
          ;;
      esac
      set -- "$@" "${arg}"
      shift
    done

    git diff --patience --word-diff --no-index "$@"
    )
}

# git and github related functions/aliases

# Start working on a pull request, this requires a .git/user-repo file
# containing the string "user/repository"
pr () {
    if [[ ! -r .git/user-repo ]]; then
        echo "Need to setup user/repo" >&2
        return 1
    fi
    local user_repo=$(< .git/user-repo)
    local pr_num=$1
    if [[ -z $pr_num ]]; then
        echo "Need the pull request number" >&2
        return 1
    fi
    local branch=merge-pr-$pr_num
    if [[ -e .git/refs/heads/$branch ]]; then
        echo "Already working on pull request $pr_num, delete branch '$branch' and try again" >&2
        return 1
    fi
    (
    set -e
    git checkout -b $branch
    curl "https://github.com/$user_repo/pull/$pr_num.patch" 2> /dev/null | git am --3way
    )
}

# Finish working on a pull request, besides the .git/user-repo file,
# this requires a .git/ghtok file containing the oauth token for accessing the
# repository
mpr () {
    if [[ ! -r .git/user-repo ]]; then
        echo "Need to setup user/repo" >&2
        return 1
    fi
    local user_repo=$(< .git/user-repo)

    local ghtok=
    if [[ -r .git/ghtok ]]; then
        ghtok=$(< .git/ghtok)
    elif [[ -n "$GITHUB_TOKEN" ]]; then
        echo "Couldn't find github token at .git/ghtok, using env \
            variable GITHUB_TOKEN" >&2
        ghtok="$GITHUB_TOKEN"
    else
        echo "Couldn't find neither .git/ghtok nor GITHUB_TOKEN, exiting" >&2
        return 1
    fi

    local pr_num=$1
    if [[ -z $pr_num ]]; then
        echo "Need the pull request number" >&2
        return 1
    fi

    local branch=merge-pr-$pr_num
    if [[ ! -e .git/refs/heads/$branch ]]; then
        echo "Not working on $pr_num" >&2
        return 1
    fi
    (
    set -e
    echo "Will push commits and comment/close on PR $pr_num"
    git checkout master
    echo "Retrieving the PR title..."
    local sed="sed"
    if [[ `uname` == 'Darwin' ]]; then
        export sed="gsed"
    fi

    # check if this is a prefixed PR ([RFC], [WIP], ...)
    local pr_meta="$(curl https://api.github.com/repos/$user_repo/issues/$pr_num 2> /dev/null)"
    local pr_title=
    if egrep -q '"\[\w+\]' <<< $pr_meta; then
        local pr_title="$($sed -n -e 's/.*"title":\s\+"\([^"]\+\)".*/\1/g' -e 's/^\[\(\w\+\)]\s*\(.\+\)/\2/p' <<< $pr_meta)"
    else
        local pr_title="$($sed -n -e 's/.*"title":\s\+"\([^"]\+\)".*/\1/p' <<< $pr_meta)"
    fi

    local merge_title="Merge #$pr_num '$pr_title'"
    local merge_title_new=
    local max_chars=72

    # check if the merge commit title doesn't surpass 80 characters
    local merge_title_chars=$(wc -c <<< "$merge_title" | tr -d ' ')
    while [[ $merge_title_chars -gt $max_chars ]]; do
      echo "$merge_title has $merge_title_chars characters, the maximum is $max_chars, please type a shorter title:"
      echo -n "Merge #$pr_num '<fill this in>': "
      read merge_title_new
      local merge_title="Merge #$pr_num '$merge_title_new'"
      local merge_title_chars=$(wc -c <<< "$merge_title" | tr -d ' ')
    done

    git merge --no-ff -m "$merge_title" $branch
    git branch -D $branch
    git log --graph --decorate --pretty=oneline --abbrev-commit --all --max-count=20
    echo "Continue with the merge? [y/N]"
    local confirm
    read confirm
    if [[ $confirm != "y" ]]; then
        echo "Merge cancelled" >&2
        git reset --hard HEAD~1
        exit 1
    fi
    git push
    curl \
        -X POST \
        -H "Authorization: token $ghtok"  \
        -d '{"body": ":+1: merged, thanks"}' \
        "https://api.github.com/repos/$user_repo/issues/$pr_num/comments" > /dev/null
    curl \
        -X PATCH \
        -H "Authorization: token $ghtok"  \
        -d '{"state": "closed"}' \
        "https://api.github.com/repos/$user_repo/issues/$pr_num" > /dev/null
    echo "Done"
    )
}
