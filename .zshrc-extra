export EDITOR=vim

# disable the extremely annoying auto-correct
unsetopt correct_all

# command with a space (' ') before them will not be remembered in
# $HISTFILE, handy for secret commands
setopt HIST_IGNORE_SPACE

# seems to be necessary to make vim mode work right
# bindkey '^[[A' history-substring-search-up
# bindkey '^[[B' history-substring-search-down

# finds the zsh-syntax-highlighting plugin in a few well-known directories
findsynhl () {
  local root=""
  if command -v brew >/dev/null 2>&1 ; then
    root="$(brew --prefix)/share/zsh-syntax-highlighting"
  fi
  if [ -d "$root" ] ; then echo -n "$root" ; return 0 ; fi
  root="$HOME/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting"
  if [ -d "$root" ] ; then echo -n "$root" ; return 0 ; fi
  return 1
}

# enable zsh syntax highlighting if available
synhl=$(findsynhl)
if [ $? -eq 0 ] ; then
  export ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR="$synhl/highlighters"
  ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)
  source "$synhl/zsh-syntax-highlighting.zsh"
fi

unset -f findsynhl

# fzf

# use ag to supply fzf with filenames instead of find, it's faster
export FZF_DEFAULT_COMMAND="ag -i --nocolor --nogroup --hidden \
  --ignore .git \
  --ignore .svn \
  --ignore .hg \
  --ignore .DS_Store \
  -g ''"

# Global fuzzy bookmark directory changer. Adapted from
# http://dmitryfrank.com/articles/shell_shortcuts.
cdg () {
   local dst="$(cdglist | fzf -0 -1 --query="$*")"
   [ -d "$dst" ] && cd "$dst"
}

# Fuzzy cd, powered by fzf. The first argument determines the depth of the
# fuzzy search. 0 is the default and search the current directory only, 1 is
# one level deeper, et cetera.
cdf () {
  local depth=${1:-1}
  cd "$(find . -mindepth 0 -maxdepth "$depth" -type d -printf '%P\n' 2>/dev/null | fzf --select-1 --exit-0)"
}

# Recursive fuzzy cd without limit, uses a depth-first search so that even
# on very slow filesystems you can navigate piecemeal. This requires bfs(1).
fd () {
  local dir
  dir="$(bfs . -type d -mindepth 1 2>/dev/null | fzf -0 -q "$*")" || {
    return 1
  }
  if [ -z "$dir" ] ; then
    echo "no more directories to enter" >&2
    return 1
  fi
  cd "$dir"
}

# A souped up version of fd that keeps going until you actually quit. Good
# for drilling down into deep hierarchies where even bfs(1) has a problem.
#
# Suppose you need to go 6 folders deep, but after 3 the hierarchy because
# too unwieldy and it gets progressively slower: then just select the
# correct folder in the 3rd level and fdr will cd into that and rerun fd.
fdr () {
    while fd "$@" ; do
      # make arguments empty
      set -- ""
    done
}

# fe [FUZZY PATTERN] - Open the selected file with the default editor
fe () {
  local file
  file=$(fzf -0 -1 --query="$1")
  [ -n "$file" ] && ${EDITOR:-vim} "$file"
}

# fh - repeat history
fh() {
  print -z $(fc -ln 1 | fzf --tac -0 -1 -q "$*")
}

# fkill - kill process
fkill () {
  pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')

  if [ "x$pid" != "x" ] ; then
    kill -${1:-9} "$pid"
  fi
}

# Make a directory and cd into it, a combination of mkdir(1) and cd.
mkcd() {
  [ -n "$1" ] && mkdir -p "$@" && cd "$1"
}

# use trusty OSX names for clipboard interaction
if [[ "$OSTYPE" == 'linux-gnu' ]] ; then
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi

# Act like pbpaste if stdin is a terminal, otherwise act like pbcopy.
clip () {
  [ -t 0 ] && pbpaste || pbcopy
}

# Return the current UNIX timestamp.
alias stamp="date +'%s'"

# make LuaJIT nicer to use from the CLI
alias luajit="rlwrap luajit"

# Print the header (the first line of input) and then run the specified
# command on the body (the rest of the input) use it in a pipeline, e.g. ps
# | body grep somepattern
body () {
  IFS= read -r header
  printf '%s\n' "$header"
  "$@"
}

# Searches text for a string but highlights instead of filtering. If you
# want to combine this with a pager, it can be piped to less because it has
# --color=always. Alternatively, one can use less -p PATTERN.
greph () {
  local pat="$1"
  shift
  grep --color=always -E "$pat|$" $@
}

# quickly find folders or files in a subdirectory
fname () {
  find . -iname "*$@*"
}

# quickly find folders or files in a subdirectory
fname0 () {
  find . -iname "*$@*" -print0
}

# execute this to try to import any running ssh-agent sessions
ssh-reagent () {
    for agent in /tmp/ssh-*/agent.*; do
       export SSH_AUTH_SOCK=$agent
       if ssh-add -l 2>&1 > /dev/null; then
           echo "Found working SSH Agent:"
           ssh-add -l
           return
       fi
   done

   echo "Cannot find ssh agent - maybe you should reconnect and forward it?"
}

# Evaluate something in lua.
le () {
  # If no arguments are given, evaluate stdin as a lua expression. We can't
  # use "lua -" as specified in the man page because that would avoid
  # printing the result if the user didn't specifically call print(),
  # write() or others. It's cumbersome to type those all the time, so do it
  # by default.
  local expr
  (( $# == 0 )) && expr="$(</dev/stdin)" || expr="$*"

  # Dirty hack to force printing of the passed in expression.
  case "$expr" in
    *print*|*write*) ;;
    *) expr="print($expr)" ;;
  esac

  eval "$(luarocks path)" &&
    LUA_INIT="@$HOME/.lua/init.lua" luajit -e "$expr"
}

# Use Lua as a UNIX filter. By default, if no "print" or "write" substrings
# are found in the passed Lua code, :each(print) will be appended. This
# prints out the result of the operators/reducers/... to stdout.
#
# When the required operation is really simple: no Lua pipelines, just a
# single operation, lefs(1) can be used with less typing.
#
# Usage: lef <lua>
# Examples:
#
#   # Add 5 to every line and print.
#   ( echo 2 ; echo 3 ) | lef "map(function(x) return x + 5 end)"
#
#   # Filter lines that are not 3.
#   ( echo 2 ; echo 3 ; echo 4) | lef "filter(function(x) return x ~= '3' end)"
#
#   # If you want to compare to the number 3 instead of the string "3", the
#   # input needs to be converted to a number with tonumber() or adding 0.
#   ( echo 2 ; echo 3 ; echo 4) | lef "filter(function(x) return x+0 ~= 3 end)"
lef () {
  # Add each(print) at the end if there's no print or io.write in the
  # command.
  local expr="$@"
  case "$expr" in
    *print*|*write*) ;;
    *) expr="${expr}:each(print)" ;;
  esac

  eval "$(luarocks path)" &&
    LUA_INIT="@$HOME/.lua/init.lua" luajit -e \
    "fun.wrap(stiter(io.lines())):$expr"
}

# Simpler invocation of lef(1) when only one operation is necessary.
# Arguments are denoted by x[1], x[2], ...
#
# Example:
#
#   # Add 5 to every line and print.
#   ( echo '2 5' ; echo '3 6' ; echo '4 7' ) | lefs "x[1] + 5"
#
# TODO(aktau): Implement string splitting.
lefs () {
  eval "$(luarocks path)" &&
    LUA_INIT="@$HOME/.lua/init.lua" luajit -e \
    "fun.wrap(stiter(io.lines())):map(function(...) local x = table.pack(...) ; return $@ end):each(print)"
}

# Start a luajit interpreter with some libraries preloaded.
lj () {
  # Add local and global rocks to the lua search path, then preload those
  # libraries and some other helper code from init.lua.
  eval "$(luarocks path)" &&
    luajit -i $HOME/.lua/init.lua --examples
}

domain-from-url () {
    local url="$1"
    python -c "from urlparse import urlparse
if '$url'.find('://') == -1:
  url = urlparse('//$url','http')
else:
  url = urlparse('$url')
print url.netloc"
}

fetch-website () {
    local dom
    local url

    if [[ "$#" -eq 2 ]]; then
        url="$2"
        dom="$1"
    else
        url="$1"
        dom=$(domain-from-url $url)
    fi

    wget \
         --recursive \
         --no-clobber \
         --page-requisites \
         --html-extension \
         --convert-links \
         --restrict-file-names=windows \
         --domains "$dom" \
         --no-parent \
         "$url"
}

# Run git-diff on files outside of a repository, to be able to make use of
# its superior diffing ability. Takes care of replacing pipe arguments with
# temporary files, because git diff chokes on those. Includes some handy git
# diff options (that I like) by default.
gdiff() {
    (
    # git diff doesn't accept pipes, so do a temporary copy of any pipes
    # passed as input.
    #
    # Iterating over the positional arguments actually iterates over a copy
    # of the positional arguments in ksh, bash and zsh.
    export TMPDIR=$(mktemp -d)
    trap "rm -rf $TMPDIR" EXIT
    for arg; do
      case "$arg" in
        -*) ;;
        *)
          # Copy the positional argument to a temporary file if it's a pipe.
          if [ -p "${arg}" ] ; then
            f="$(mktemp)" || exit
            cp "${arg}" "$f"
            arg="$f"
          fi
          ;;
      esac
      set -- "$@" "${arg}"
      shift
    done

    git diff --patience --word-diff --no-index "$@"
    )
}

# git and github related functions/aliases

# Start working on a pull request, this requires a .git/user-repo file
# containing the string "user/repository"
pr () {
    if [[ ! -r .git/user-repo ]]; then
        echo "Need to setup user/repo" >&2
        return 1
    fi
    local user_repo=$(< .git/user-repo)
    local pr_num=$1
    if [[ -z $pr_num ]]; then
        echo "Need the pull request number" >&2
        return 1
    fi
    local branch=merge-pr-$pr_num
    if [[ -e .git/refs/heads/$branch ]]; then
        echo "Already working on pull request $pr_num, delete branch '$branch' and try again" >&2
        return 1
    fi
    git checkout -b $branch
    if ! curl -L "https://github.com/$user_repo/pull/$pr_num.patch" 2> /dev/null | git am --3way ; then
        echo "Downloading patch or patching failed, please resolve manually"
        git am --abort
        git checkout master
        git branch -D $branch
    fi
}

# Finish working on a pull request, besides the .git/user-repo file,
# this requires a .git/ghtok file containing the oauth token for accessing the
# repository
mpr () {
    if [[ ! -r .git/user-repo ]]; then
        echo "Need to setup user/repo" >&2
        return 1
    fi
    local user_repo=$(< .git/user-repo)

    local ghtok=
    if [[ -r .git/ghtok ]]; then
        ghtok=$(< .git/ghtok)
    elif [[ -n "$GITHUB_TOKEN" ]]; then
        echo "Couldn't find github token at .git/ghtok, using env \
            variable GITHUB_TOKEN" >&2
        ghtok="$GITHUB_TOKEN"
    else
        echo "Couldn't find neither .git/ghtok nor GITHUB_TOKEN, exiting" >&2
        return 1
    fi

    local pr_num=$1
    if [[ -z $pr_num ]]; then
        echo "Need the pull request number" >&2
        return 1
    fi

    local branch=merge-pr-$pr_num
    if [[ ! -e .git/refs/heads/$branch ]]; then
        echo "Not working on $pr_num" >&2
        return 1
    fi
    (
    set -e
    echo "Will push commits and comment/close on PR $pr_num"
    git checkout master
    echo "Retrieving the PR title..."
    local sed="sed"
    if [[ `uname` == 'Darwin' ]]; then
        export sed="gsed"
    fi

    # check if this is a prefixed PR ([RFC], [WIP], ...)
    local pr_meta="$(curl https://api.github.com/repos/$user_repo/issues/$pr_num 2> /dev/null)"
    local pr_title=
    if egrep -q '"\[\w+\]' <<< $pr_meta; then
        local pr_title="$($sed -n -e 's/.*"title":\s\+"\([^"]\+\)".*/\1/g' -e 's/^\[\(\w\+\)]\s*\(.\+\)/\2/p' <<< $pr_meta)"
    else
        local pr_title="$($sed -n -e 's/.*"title":\s\+"\([^"]\+\)".*/\1/p' <<< $pr_meta)"
    fi

    local merge_title="Merge #$pr_num '$pr_title'"
    local merge_title_new=
    local max_chars=72

    # check if the merge commit title doesn't surpass 80 characters
    local merge_title_chars=$(wc -c <<< "$merge_title" | tr -d ' ')
    while [[ $merge_title_chars -gt $max_chars ]]; do
      echo "$merge_title has $merge_title_chars characters, the maximum is $max_chars, please type a shorter title:"
      echo -n "Merge #$pr_num '<fill this in>': "
      read merge_title_new
      local merge_title="Merge #$pr_num '$merge_title_new'"
      local merge_title_chars=$(wc -c <<< "$merge_title" | tr -d ' ')
    done

    git merge --no-ff -m "$merge_title" $branch
    git branch -D $branch
    git log --graph --decorate --pretty=oneline --abbrev-commit --all --max-count=20
    echo "Continue with the merge? [y/N]"
    local confirm
    read confirm
    if [[ $confirm != "y" ]]; then
        echo "Merge cancelled" >&2
        git reset --hard HEAD~1
        exit 1
    fi
    git push
    curl \
        -X POST \
        -H "Authorization: token $ghtok"  \
        -d '{"body": ":+1: merged, thanks"}' \
        "https://api.github.com/repos/$user_repo/issues/$pr_num/comments" > /dev/null
    curl \
        -X PATCH \
        -H "Authorization: token $ghtok"  \
        -d '{"state": "closed"}' \
        "https://api.github.com/repos/$user_repo/issues/$pr_num" > /dev/null
    echo "Done"
    )
}

_nman() {
    local l=$#
    local -a page
    page=(${@:1:$l-1})
    if [[ -z "$page" ]]; then
        echo "What manual page do you want?"
        return
    fi
    local tmp=$IFS
    IFS=$'\n' out=($(command man -w ${page[@]} 2>&1))
    local code=$?
    IFS=$tmp
    if [[ ${#out[@]} > 1 ]]; then
        echo "Too many manpages"
        return
    elif [[ $code != 0 ]]; then
        echo "No manual entry for ${page[*]}"
        return
    fi
    if [[ -z $NVIM_LISTEN_ADDRESS ]]; then
        command nvim -c "${@: -1} ${page[*]}"
    else
        nvr --remote-send "<c-n>" -c "${@: -1} ${page[*]}"
    fi
}

nman() {
    _nman "$@" 'Nman'
}

nman!() {
    _nman "$@" 'Nman!'
}
